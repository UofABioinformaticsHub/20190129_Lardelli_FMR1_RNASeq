##RNAseq analysis using sample data and protocol from https://f1000research.com/articles/5-1408/v1
#Melanie Hand
#26 May 2019

#Alignments were generated by aligning each library to the Zebrafish genome
#Samples are from 2 groups: Wildtype and FMR1 knockout
#featureCounts was re-run with additional parameters:
  # -s 2 to indicate reverse stranded library
  #--fracOverlap 1 to specify 100% of read needs to overlap for read assignment

#this extra stringency resulted in fewer reads being assigned
#approx 43% of the number of reads were assigned compared to running
#running with parameters -s 0 and -fracOverlap 0 (see counts.out files)

library(edgeR)
library(limma)
library(RColorBrewer)
library(biomaRt)
library(magrittr)
library(tidyverse)
library(AnnotationHub)
library(ggrepel)
library(plyr)

##DATA PACKAGING

##Reading in count data

#load the gene count file generated by featureCounts
count.file <- read.delim("genes.s2.exonic.out", row.names="Geneid")

#edit sample names from coutnfile by removing excess text
#each time featureCounts runs, sample order can change
#so it's best to rename samples this way to prevent accidentally mislabelling samples

samplenames <- colnames(count.file) %>%
  str_remove("X.fast.users.a1222913.20190129_Lardelli_FMR1_RNASeq.2_alignedData.bams.") %>%
  str_remove("_Aligned.+")

#rename the columns
colnames(count.file) <- samplenames

#convert to DGEList object and normalise data
x <- DGEList(counts=count.file) %>%
  calcNormFactors()

#class is a DGEList
class(x)

#check the dimensions of the matrix

dim(x)

##Organising sample information

#check the sample names
x$samples

#associate the sample origin to each sample in the matrix
#group must then be converted to factor
#by default, the group order will be chosen alphabetically and the ref is the first group
#but if left default, FMR1 would be reference
#define levels to make sure Wildtype is first and therefore reference

targets <- tibble(sample = colnames(x),
                  group = case_when(
                    sample %in% paste0("S", 1:8) ~ "FMR1",
                    !sample %in% paste0("S", 1:8)  ~ "Wildtype"
                  )) 

group <- factor(targets$group, levels = c("Wildtype", "FMR1"))

#create a new column in the matrix samples dataframe called group and assign the group names just created

x$samples$group <- targets$group
x$samples$group
x$samples


##Organising gene annotations

#A second data frame named genes in the DGEList-object is used to store 
#gene-level information associated with rows of the counts matrix.
#This information can be retrieved using organism specific packages such as 
#Mus.musculus for mouse (or Homo.sapiens for human) or the biomaRt package

#access zebrafish annotation database using biomaRt

mart <- useMart("ENSEMBL_MART_ENSEMBL")

datasetlist <- listDatasets(mart)

drerio.mart <- useMart("ENSEMBL_MART_ENSEMBL", "drerio_gene_ensembl")

martAttributes <- listAttributes(drerio.mart)

#create a list of the ensembl_gene_id from count file
geneIDs <- row.names(count.file)

#retrieve attributes gene name, description, chromosome_name and ensembl_gene_id from zebrafish annotation database
#use values listed in the count.file which are filter type ensembl_gene_id
att2Get <- c("ensembl_gene_id", "chromosome_name", "description", "external_gene_name")
gene.details <- getBM(attributes=att2Get,
                      filters="ensembl_gene_id",
                      values=geneIDs,
                      mart=drerio.mart)

#can alternatively use AnnotationHub to create an EndDb
#but Danio rerio genome EnsDb 94 not yet available (on Windows?)
# ah <- AnnotationHub() %>%
#   subset(species == "Danio rerio") %>%
#   subset(dataprovider == "Ensembl") %>%
#   subset(rdataclass == "EnsDb")
# ah
# ensDb <- AnnotationHub()[["AH64906"]]

#no duplicate gene IDs in this list. No need to remove duplicates.

#the data frame of gene annotations is added to the data object
#first convert to a tibble
#left_join is like vlookup. Use this to keep in the same order as in x
#create a new column in x called genes and add the gene information (EntrezID, Symbol and TxChr)
x$genes <- tibble(ensembl_gene_id = rownames(x)) %>%
  left_join(gene.details)
x$genes

#now the DGEList x has 3 elements: samples, counts and genes
x

##DATA PRE-PROCESSING


##Transforming from the raw scale

#convert count data in the DGEList object to cpm and lcpm using edgeR package

cpm <- cpm(x)
lcpm <- cpm(x, log=TRUE)

##Removing genes that are not expressed

#find how many genes have a count of 0 across all 8 samples
table(rowSums(x$counts==0)==8)

#create a plot showing density of log-CPM values for raw pre-filtered data
nsamples <- ncol(x)
col <- brewer.pal(nsamples, "Paired")
plot(density(lcpm[,1]), col=col[1], lwd=2, ylim=c(0,0.21), las=2,
     main="", xlab="")
title(main="A. Raw data", xlab="Log-cpm")
abline(v=0, lty=3)
for (i in 2:nsamples){
  den <- density(lcpm[,i])
  lines(den$x, den$y, col=col[i], lwd=2)
}
legend("topright", samplenames, text.col=col, bty="n")

## Steve's quick version
par(mfrow= c(1,1))
x %>%
  cpm(log = TRUE) %>%
  plotDensities(legend = "topright")


#a gene is deemed to be expressed in a given sample if its transformed count is above 
#cpm=1 (log-cpm=0) otherwise it is unexpressed
#Genes must be expressed in at least one group (or roughly any four samples 
#across the entire experiment) to be kept for downstream analysis.

#keep only genes expressed in >= 4 samples
keep.exprs <- rowSums(cpm>1)>=4
table(keep.exprs) #shows that 13781 genes will be discarded, 18276 retained

#subset x with only the expressed genes
x <- x[keep.exprs,, keep.lib.sizes=FALSE] 

dim(x) #shows now only have 18276 genes and 8 samples

#create a plot showing density of log-CPM values for raw pre-filtered data (A) and post-filtered data (B)
nsamples <- ncol(x)
col <- brewer.pal(nsamples, "Paired")
par(mfrow=c(1,2))
plot(density(lcpm[,1]), col=col[1], lwd=2, ylim=c(0,0.21), las=2,
     main="", xlab="")
title(main="A. Raw data", xlab="Log-cpm")
abline(v=0, lty=3)
for (i in 2:nsamples){
  den <- density(lcpm[,i])
  lines(den$x, den$y, col=col[i], lwd=2)
}
legend("topright", samplenames, text.col=col, bty="n")
lcpm <- cpm(x, log=TRUE)
plot(density(lcpm[,1]), col=col[1], lwd=2, ylim=c(0,0.21), las=2,
     main="", xlab="")
title(main="B. Filtered data", xlab="Log-cpm")
abline(v=0, lty=3)
for (i in 2:nsamples){
  den <- density(lcpm[,i])
  lines(den$x, den$y, col=col[i], lwd=2)
}
legend("topright", samplenames, text.col=col, bty="n")

##Normalising gene expression distributions

#Normalisation is generally required to ensure that the expression distributions 
#of each sample are similar across the entire experiment.

#normalisation by the method of trimmed mean of M-values (TMM) is performed 
#using the calcNormFactors function in edgeR

xnorm <- calcNormFactors(x, method="TMM")

#compare normalisation factors pre- and post- normalisation
x$samples$norm.factors
xnorm$samples$norm.factors

#compare lcpm between samples before and after normalisation
par(mfrow=c(1,2))
lcpm <- cpm(x, log=TRUE)
boxplot(lcpm, las=2, col=col, main="")
title(main="A. Example: Unnormalised data",ylab="Log-cpm")
lcpm_xnorm <- cpm(xnorm, log=TRUE)
boxplot(lcpm_xnorm, las=2, col=col, main="")
title(main="B. Example: Normalised data",ylab="Log-cpm")

##Unsupervised clustering of samples

#multidimensional scaling (MDS) plot gives a good illustration of similarity and dissimilarity between samples
#technical reps should lie close to each other
#samples should cluster well within the primary condition of interest
#any sample straying far from its group could be identified and followed up for sources of error or extra variation

par(mfrow=c(1,2))
col.group <- group #create a variable for group colours
levels(col.group) <- brewer.pal(nlevels(col.group), "Set1") #create a colour palette called Set1 of n colours (1 colour for each group)
col.group <- as.character(col.group)
col.sample <- as.factor(rownames(x$samples))
levels(col.sample) <- brewer.pal(nlevels(col.sample), "Set2")
col.sample <- as.character(col.sample)
plotMDS(lcpm, labels=group, col=col.group)
title(main="A. Sample groups")
plotMDS(lcpm, labels=rownames(x$samples), col=col.sample, dim=c(1,2)) #dim specifies to plot dimensions 3 and 4
title(main="B. Samples")

?plotMDS

#Sample D doesn't cluster as much with other wildtype samples


##DIFFERENTIAL EXPRESSION ANALYSIS

##Creating a design matrix and contrasts

#in this experiment we want to check which genes are expressed at different levels
#between wildtype and FMR1 knockout

#To get started, a design matrix is set up with group information.

design <- model.matrix(~group)
colnames(design) <- c("Wildtype", "FMR1vsWildtype")

design

#no need to set up contrasts here as only 1 variable
#set up model contrasts for pairwise comparisons (contrasts = comparisons)
#contr.matrix <- makeContrasts(
#Wildtype_vs_FMR1 = Wildtype-FMR1,
#levels = colnames(design))
#contr.matrix


##Removing heteroscedasticity from count data

#In RNA-seq count data, the variance is not independent of the mean
#the voom function is used to accommodate the mean-variance function
#use voom with quality weights to weight each sample. 
#With this, a sample's contribution will depend on its quality
#the sample weights get added as a column in v$targets

par(mfrow=c(1,1))
v <- voomWithQualityWeights(x, design = matrix(1, ncol = 1, nrow = ncol(x)), plot=TRUE)
#v <- voom(x, plot=TRUE)
v

#the plot shows the relative weight of each sample
#if all were contributing equally, all would have a weight of 1
#one of the samples has a weighting much higher than others (>2)

#create another plot to show this in more detail and determine which sample has the high weighting

v$targets %>%
  rownames_to_column("sample") %>%
  ggplot(aes(sample, sample.weights, fill = group)) +
  geom_bar(stat = "identity") +
  geom_hline(yintercept = 1, linetype = 2, colour = "blue") +
  theme_bw()

#the plot shows that sample G is overly weighted compared to the other samples
#good idea to sum the weights for each group
#the more similar weight totals per group, the better
#here, wildtype has a greater total weight than FMR1



#the result is an EList object that contains multiple dataframes, 
#including genes and samples and the design matrix
v$genes
v$targets 
v$E
v$weights
v$design 

##Fitting linear models for comparisons of interest

#Linear modelling in limma is carried out using the lmFit and contrasts.fit functions
#Next, empirical Bayes moderation is carried out by the eBayes function

vfit <- lmFit(v, design)

#vfit <- contrasts.fit(vfit, contrasts=contr.matrix)
efit <- eBayes(vfit)
plotSA(efit)


##Examining the number of DE genes

#For a quick look at differential expression levels, the number of significantly up- 
#and down-regulated genes can be summarised in a table. 
#p-value cutoff is set at 5% by default

summary(decideTests(efit))

#only 5 DE genes identified with this p-value threshold
#create a list of all DE genes (Inf means include all)
#sort by p-value so the 5 DE Genes are at the top

deGenes <- topTable(efit, coef = "FMR1vsWildtype", number = Inf, sort.by = "p")

#create a volcano plot to show logFc vs p-value
#first create a new column (Sig) where the significant genes 
#are differenitated so they can be coloured differently (p<0.05=TRUE, p>0.05=FALSE)
#geom_text_repel makes sure lables don't overlap
#label with gene names, but only for significant ones
#colour all non Sig genes grey with a transparency on 0.5
#colour Sig genes red
#vertical dashed lines added at logFC= 1 and logFC= -1 which represent 2 fold change in either direction
#logFC = 1 == FC = 2

deGenes %>%
  mutate(Sig = adj.P.Val < 0.05) %>%
  ggplot(aes(logFC, -log10(P.Value), colour = Sig)) +
  geom_point() +
  geom_text_repel(aes(label = external_gene_name), 
                  data = . %>% dplyr::filter(Sig)) +
  geom_vline(xintercept = c(-1, 1), linetype = 2, colour = "grey50") +
  geom_hline(yintercept = -log10(2.138526e-06), linetype = 2, colour = "blue") +
  scale_colour_manual(values = c(rgb(0.5, 0.5, 0.5, 0.5), "red")) +
  theme_bw() +
  theme(legend.position = "none")

#some samples appear to have strong logFC, but a low (high?) p-value
#this is likely the result of the gene having very variable expression across the samples
#eg, it might be significant (low p value) in some samples within a group, but not all

#encouragingly, fmr1 is significantly down expressed in FMR1 knowckouts compared to WT
#extract cpm values for only this gene and plot expression across all samples

cpm(x) %>%
  .["ENSDARG00000037433",] %>%
  as.data.frame() %>%
  set_colnames("CPM") %>%
  rownames_to_column("sample") %>%
  cbind(x$samples[.$sample,]) %>%
  ggplot(aes(sample, CPM, fill = group)) +
  geom_bar(stat = "identity") +
  scale_y_log10() +
  theme_bw()

#the plot confirms FMR1 expression is lower in all FMR1 samples compared to WT

#it is also useful to plot the average expression vs logFC 
#to see if the significant genes are high or lowly expressed

deGenes %>%
  mutate(Sig = adj.P.Val < 0.05) %>%
  ggplot(aes(AveExpr, logFC, colour = Sig)) +
  geom_point() +
  geom_text_repel(aes(label = external_gene_name), 
                  data = . %>% dplyr::filter(Sig)) +
  geom_hline(yintercept = c(-1, 1), linetype = 2, colour = "grey50") +
  scale_colour_manual(values = c(rgb(0.5, 0.5, 0.5, 0.5), "red")) +
  theme_bw() +
  theme(legend.position = "none")

#this plot doesn't look at p value (significance)
#so some genes look interesting (large FC) but are not significant

#export the list of DE genes

write.csv(deGenes, "DE_genes_FMR1vWildtype_s2Exonic.csv")

#the file has the following columns:
#logFC: log2 fold change based on the contrast specified. log2FC of 1 = 2 fold change
#AveExpr: average log2 expression of the gene (-ve number means expression between 0 and 1)
#t: moderated t-statistic
#P.Value: raw p-value
#adj.P.Value: p-value adjusted to control the false discovery rate
#B: log-odds that the gene is differentially expressed. A B value of 0 means a gene has 50% chance of being differentially expressed
#Genes sorted by B value should give same order as if sorted by p-value, but only if quality weights are not used

#we want to check if genetic compensation is occurring
#when a gene is knocked out, genes with similar sequences are often upregulated to compensate
#to check, we can first determine which genes in the D.rerio genome have similarity to frm1
#use blast to find similar genes


#used web based ensemble BLAST to query zebrafish cDNAs with FMR1 CDS
#used blastn and genome version Dr_GRCz11

#input the results file
blastn <- read.csv("FMR1_blastn_Dr_GRCz11_cDNAs.csv", header=TRUE)

#the IDs are transcript IDs. Want to convert to the gene ID to compare with the dataset
#can do this using biomaRt
transcriptIDs <- blastn$Subject.name

#access zebrafish annotation database using biomaRt

mart <- useMart("ENSEMBL_MART_ENSEMBL")

datasetlist <- listDatasets(mart)

drerio.mart <- useMart("ENSEMBL_MART_ENSEMBL", "drerio_gene_ensembl")

martAttributes <- listAttributes(drerio.mart)

#retrieve attributes ensembl_gene_id zebrafish annotation database
#use values listed in the blast results which are filter type ensembl_transcript_id_version
blast.gene.details <- getBM(attributes=c("ensembl_gene_id", "ensembl_transcript_id_version"),
                            filters="ensembl_transcript_id_version",
                            values=transcriptIDs,
                            mart=drerio.mart)

#add the geneID to the blast results data frame
blastn <- left_join(blastn, blast.gene.details, by=c("Subject.name" = "ensembl_transcript_id_version"))

#are any of these in the list of DE genes?
#create an extra column in deGenes called 'similar' that displays TRUE
#if the geneID was in the blast results
deGenes2 <- mutate(deGenes, similar = ensembl_gene_id %in% blastn$ensembl_gene_id)

#check how many of the blast result genes are in deGenes2
dim(dplyr::filter(deGenes2, similar))

#11 of the genes are present in the list

#add the deGene information to the blastn results table
blastn_all <- left_join(blastn, deGenes)

#export the table
write.csv(blastn_all, "fmr1_blastn_results_s2_exonic.csv")

#now create a new volcano plot where these 11 genes are coloured differently

deGenes2 %>%
  mutate(Sig = adj.P.Val < 0.05) %>%
  arrange(desc(P.Value)) %>%
  ggplot(aes(logFC, -log10(P.Value), colour = similar)) +
  geom_point() +
  geom_text_repel(aes(label = external_gene_name), 
                  data = . %>% dplyr::filter(similar)) +
  geom_vline(xintercept = c(-1, 1), linetype = 2, colour = "grey50") +
  scale_colour_manual(values = c(rgb(0.5, 0.5, 0.5, 0.5), "red")) +
  theme_bw() +
  theme(legend.position = "none")


#the fmr1 similar genes are not significantly upregulated

#now plot average expression vs logFC

deGenes2 %>%
  mutate(Sig = adj.P.Val < 0.05) %>%
  arrange(desc(P.Value)) %>%
  ggplot(aes(AveExpr, logFC, colour = similar)) +
  geom_point() +
  geom_text_repel(aes(label = external_gene_name), 
                  data = . %>% dplyr::filter(similar)) +
  geom_hline(yintercept = c(-1, 1), linetype = 2, colour = "grey50") +
  scale_colour_manual(values = c(rgb(0.5, 0.5, 0.5, 0.5), "red")) +
  theme_bw() +
  theme(legend.position = "none")




